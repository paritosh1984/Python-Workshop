\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{listings}
%\usepackage{subfig}
\usetheme{Copenhagen}
\usecolortheme{seahorse}
 

%Information to be included in the title page:
\title{Objects and Classes}
\author{Vivek K. S., Deepak G.}
\institute{Information Systems Decision Sciences (ISDS)\\
MUMA College of Business\\
University of South Florida \\
Tampa, Florida}
\date{2017}

\expandafter\def\expandafter\insertshorttitle\expandafter{%
\insertshorttitle\hfill%
\insertframenumber\,/\,\inserttotalframenumber}

\lstset{language=python,
		showstringspaces=false,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{purple}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}
 
\begin{document}
\frame{\titlepage}

\begin{frame}
\frametitle{What are Objects?}
\begin{itemize}
\item Everything in Python is an object. That includes numbers, strings, sequences, functions, modules and packages.
\item An object contains both data and the methods that define the behaviour it could be part of, in the program.
\item For example, an integer object contains numerical data and could become part of arithmetic operations such as addition,exponentiation etc.
\item Objects are instances of larger, concrete templates called as Classes. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Classes}
\begin{itemize}
\item Classes are used to define data types and behaviours in Object-oriented programming paradigm.
\item Once a class is defined, instances of the classes could be spawned easily whenever required.
\item A simple class definition looks like this:

\begin{lstlisting}[language=Python]
class Student():
	def __init__(self, name):
		self.name = name
		
student = Student('Rick')
student.name
'Rick'
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Explanation}
\begin{itemize}
\item The code has different components to it. The keyword 'class' is used to create a new class definition.
\item The class has a name and in this case, it is "Student". We are going to create a custom Student data type.
\item No arguments are passed to it.
\item The \_\_init\_\_ is the initializer function in Python. Note that it is written with two trailing underscores and two leading underscores.
\item The first argument passed to the init function is always a reference that points to the current object instance. In Python, we use "self" to represent this reference.
\item \textit{Self} is not a keyword as such. But it is good practice to use \textit{Self} for this purpose.
\item The instance has one property called the name and it is initialized as seen in the code:
self.name = name
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Explanation}
Here is what the following code does:

student = Student('Rick')
\begin{itemize}
\item Looks up the definition of the Student class in the current namespace.
\item Instantiates/Creates a new object in the memory.
\item Calls the init method (which is the initializer), passing the newly created object reference as "self" along with the other argument 'Rick' as the name of the student.
\item Assigns the value of the name to the newly created object.
\item And it finally returns the new object.
\item Assigns the object itself to the variable student. Now student is a reference that points to the Student object residing in the memory with the name "Rick".
\item This new object can be used for any purpose in the program, as far as its data type and behavioral definition supports them.
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{The Constructor and Initializer Function}
\begin{itemize}
\item The init method is used to initialize the object we are creating.
\item In this example, we are initializing the  instance's \textit{name} property with a value that is passed to the name argument(Rick).
\item The self is simply a reference to that particular instance.
\item Since, self already is a reference to the instance, it is understood that the instance has been already been created.
\item This is done implicitly by the \textbf{\_\_new\_\_} function whose implementation is hidden from us. 
\item The new function is the Constructor function in Python. It builds/instantiates(creates) the object instance in the memory.
\item It can be overridden in special cases.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Inheritance}
Inheritance is the way to extend an existing Class's definition to add or change some behaviors of that class without disturbing the original definition. 
It is a very powerful feature and offers various advantages.
\begin{itemize}
\item  When a class is inherited from, all the properties of it are inherited without the need to copy any code.
\item If anything is to be changed, we simply override that particular behavior.
\item The original class is commonly called as base, parent or superclass and the inheriting class is called a derived, child or subclass.

\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Overriding a Method}
A child class inherits everything from its parent class. But the methods of the Parent class can be overridden.
All the methods including the init method can be overriden.
\begin{lstlisting}[language=Python]
class Faculty():
	def __init__(self, name):
		self.name = name
class Doctor(Faculty):
	def __init__(self, name):
		self.name = 'Doctor ' + name
class Professor(Faculty):
	def __init__(self, name):
		self.name = 'Professor ' + name

Felicia = Doctor('Felicia')
Warren = Professor('Warren')
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding a Method}
A child class could also add a method that is not there as part of the Parent's class definition.
\begin{lstlisting}[language=Python]
class Faculty():
    def __init__(self, name):
        self.name = name
class Doctor(Faculty):
    def __init__(self, name):
        self.name = 'Doctor ' + name
    def teach(self):
        print(self.name,'teaches Graduates.')
class Professor(Faculty):
    def __init__(self, name):
        self.name = 'Professor ' + name
    def teach(self):
        print(self.name,'teaches Undergrads.')
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Using Super()}
\begin{itemize}
\item Sometimes, the child might want to do things the exact same way the Parent does. 
\item In these cases, it is advisable that we directly invoke the property of choice of the Parent using super().

\item The super() holds the definition of the Parent class.
\begin{lstlisting}[language=Python]
class Faculty():
    def __init__(self, name):
        self.name = name
    
class Professor(Faculty):
    def __init__(self, name, email):
        super().__init__(name)
        self.email = email        
\end{lstlisting}

\item The advantage of this is that whenever the Parent class definition changes, it is automatically reflected in the child as well.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Types of Methods in Classes}
\begin{itemize}
\item There are three types of methods in classes.
\begin{itemize}
\item Class methods,
\item Instance methods and 
\item Static methods.
\end{itemize}
\item Some attributes and methods are part of the class itself and some are only part of the object instances of the class.
\item The way to differentiate between them is by using the "self" argument. When we encounter a self argument in the methods within the class, we can conclude that they are instance methods.
\item The first argument to an instance method is always self, and whenever these instance methods are called (with the objects using dot notation method of calling), the object itself is passed to the method.
\item Instance method only affect the object instance calling them. Whereas, a class method affects the entire class. Any change made to the class affects all the objects.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Types of Methods in Classes}
\begin{itemize}
\item A @classmethod decorator indicates a class method.Here, the first parameter to the method is the class itself.
\item Like how "self" is used for object instances, we use "cls" as a reference to the class object.
\begin{lstlisting}
class Car():
	count = 0
	def __init__(self):
		Car.count += 1
	@classmethod
	def car_counter(cls):
		print("Car has ",cls.count, 
		" cars")       
\end{lstlisting}
\item Instead of cls.count, we could very well use "Car.count" as well.
\item The car\_counter() method can be accessed by each object of the class as well.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Types of Methods in Classes - Static Methods}
\begin{itemize}
\item A third type of method is the static  method. It neither affects the class nor the objects.
\item Its defined with a @staticmethod decorator with no initial self or cls parameter.
\begin{lstlisting}
class Car():
	@staticmethod
	def promo():
		print('All these cars are for 
		sale!!')
Car.promo()
All these cars are for sale!!
\end{lstlisting}
\item Notice that we did not have to create objects of the class to access this method.
\item Static methods do not have access to instance attributes or class attributes.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Summary}
\begin{itemize}
\item Object oriented programming gives the programmer a great deal of advantage in creating custom data types and to contain logic and data together.
\item We learned how to create classes and object instances. We learned what constructors and initialzers are.
\item We learned how to define methods that need to work on the data type inside the class definition.
\item We learned method overriding and class inheritance, and
\item We learned the different types  of methods.
\end{itemize}
\end{frame}
\end{document}
