\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{listings}
%\usepackage{subfig}
\usetheme{Copenhagen}
\usecolortheme{seahorse}
 

%Information to be included in the title page:
\title{For Loops and Comprehensions}
\author{Vivek K. S., Deepak G.}
\institute{Information Systems Decision Sciences (ISDS)\\
MUMA College of Business\\
University of South Florida \\
Tampa, Florida}
\date{2017}


\expandafter\def\expandafter\insertshorttitle\expandafter{%
\insertshorttitle\hfill%
\insertframenumber\,/\,\inserttotalframenumber}

\lstset{language=python,
		showstringspaces=false,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{purple}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}


\begin{document}
\frame{\titlepage}

\begin{frame}
\frametitle{For Loop and Iterators}
Python uses For loop to iterate over sequential data structures.
\begin{itemize}
\item Iterators are used to go over sequential data structures, one element at a time.
\item The process is incremental in nature.
\item They can be used to process data residing in the memory and also data created on the fly. This helps in processing large chunks of data that cannot be fit into the computer's memory at once.
\item Lists, Strings, Tuples, Sets, Dictionaries are all iterable objects in Python.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Iterating Over a List}
We can iterate over a list as follows:
\begin{lstlisting}[language=Python]

seq = ['lists','tuples','dictionaries','sets']
count = 0
while count < len(seq):
    print(seq[count])
    count += 1  

# The more pythonic way of doing it will be.
for s in seq:
    print(s)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Iterating Over other Types}
Other Iterables can be iterated as follows:
\begin{lstlisting}[language=Python]
# Strings
word = 'Bootcamp'
for letter in word:
	print(letter)

# Dictionaries
information = {'dept': 'isds', 'college': 'Muma',
'university': 'USF'}
for info in information.items():
    print(info)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Iterating Multiple Sequences with zip()}
Multiple Sequences can be iterated in parallel using zip without the need to write complex nested for loops.
\begin{lstlisting}
days = ['Monday', 'Tuesday', 'Wednesday']
fruits = ['banana', 'orange', 'peach']
drinks = ['coffee', 'tea', 'beer']
desserts = ['tiramisu', 'ice cream', \
'pie', 'pudding']
for day, fruit, drink, dessert in\
 zip(days, fruits, drinks, desserts):
    print(day, ": drink", drink, "- eat",\
     fruit, "- enjoy", dessert)
\end{lstlisting}

Note - zip() stops when the shortest sequence is done.
\end{frame}


\begin{frame}[fragile]
\frametitle{Creating Iterables with zip}
zip() can also be used to walk through multiple sequences and make tuples from items at the same offsets.
\begin{lstlisting}	

english = 'Monday', 'Tuesday', 'Wednesday'
french = 'Lundi', 'Mardi', 'Mercredi'

days = list(zip(english, french))
print(days)
[('Monday', 'Lundi'), ('Tuesday', 'Mardi'),
 ('Wednesday', 'Mercredi')]

dict(zip(english, french))
{'Monday': 'Lundi', 'Tuesday': 'Mardi',
 'Wednesday': 'Mercredi'}
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{The Range() function}
The range() function returns a stream of numbers within a specified range. This function helps enormously in saving crucial computer memory.
\begin{itemize}
\item Range returns an iterable object.
\item The syntax of the method is, range(start,stop,steps)
\item If start is not specified, the range starts at 0.
\item Stop is absolutely required.
\item The default step size is 1. Negative step values are valid as well.
\end{itemize}
\begin{lstlisting}
Example,
for x in range(0,3):
	print(x)

\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{More Code Examples}
More code examples are available at --
 
\url{https://github.com/vivek14632/Python-Workshop/tree/master/Introducing\%20Python/Chapter\%204}
\end{frame}

\begin{frame}[fragile]
\frametitle{Comprehensions in Python}
Comprehensions is the Pythonic way of creating sequential data and they improve readability.

Here is how one might add elements to a list.
\begin{lstlisting}
>>> number_list = []
>>> number_list.append(1)
>>> number_list.append(2)
>>> number_list.append(3)
>>> number_list.append(4)
>>> number_list.append(5)
>>> number_list
[1, 2, 3, 4, 5]
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Comprehensions in Python}
The same result could be achived as follows:
\begin{lstlisting}
number_list = []
for num in range(1,6):
    number_list.append(num)
number_list
[1, 2, 3, 4, 5]

# To further shorten it.
number_list = list(range(1, 6))
number_list
[1, 2, 3, 4, 5]
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Comprehensions in Python}
Though all of the approaches stated in the previous slides are valid and will produce the same result, they are not Pythonic. The simplest way to build a list is to use a list comprehension as follows:
\begin{lstlisting}
number_list = [number for number in range(1,6)]

# If that looks big and if you want to 
# shorten it.
number_list = [x for x in range(1,6)]

\end{lstlisting}

In general, a list comprehension takes up the general syntax:

[ expression for item in iterable ]
\end{frame}

\begin{frame}[fragile]
\frametitle{Examples}
Couple of examples for List Comprehensions:
\begin{lstlisting}
# List of squares from 1 through 10
squares = [x**2 for x in range(1,11)]
squares
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# Multiples of 5
mult_of_5 = [5*x for x in range(1,11)]
mult_of_5
[5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Conditional Expressions in Comprehensions}
Comprehensions can also include conditional expressions as follows:
[ expression for item in iterable if condition ]
\begin{lstlisting}

# Filtering just the even squares in the 
# from the previous list

even_squares = [x**2 for x in range(1,11) if
 (x**2)%2==0]
even_squares
[4, 16, 36, 64, 100]

\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Avoiding Nested Loops Using Comprehensions}
Comprehensions can get rid of the need for nested loops as seen below:
\begin{lstlisting}

rows = [1,2,3,5,6]
cols = [1,4,6,7,8]
for row in rows:
    for col in cols:
        print(row, col)
        
# This can be reduced down to
cells = [(row, col) for row in rows for col\
 in cols]

\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Using Comprehensions for Other Sequential Types}
\begin{itemize}
\item Comprehensions can be used to create other sequential data types as well and not just Lists.
\item Dictionary Comprehension take the form:
\begin{lstlisting}
{key_expr: value_expr for expr in iterable}
# expr is short for expression.
\end{lstlisting}
\item Set expressions take the form as follows:
\begin{lstlisting}
{expression for expression in iterable}
\end{lstlisting}
\item Tuples do not have comprehensions. 
\item Enclosing a similar syntax inside a pair of parantheses instead creates a generator.
\begin{lstlisting}
>>>compr = (number for number in range(1, 6))
>>>type(compr)
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{More Examples in Lists}
More code examples are available at --
 
\url{https://github.com/vivek14632/Python-Workshop/tree/master/Introducing\%20Python/Chapter\%204}
\end{frame}


\begin{frame}
\frametitle{Summary}
\begin{itemize}
\item We understood higher iterating structures such as zip and sequence generators such as range().
\item We understood and implemented comprehensions thereby getting rid of the need of complex code pieces, making it more readable.
\item We learned the "Pythonic" way of coding.
\end{itemize}
\end{frame}
\end{document}